[{"title":"iOS3D变换以及透视、阴影详解","url":"http://www.dengbo.me/2016/09/08/iOS3D变换以及透视、阴影详解/","content":"<h2 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h2><p>最近在学习iOS Core Animation相关的内容，第五章3D变换里有一个Demo，是在屏幕上显示一个正方体，并且为其添加光照阴影，效果图如下所示：</p>\n<p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%202.png\" alt=\"效果图\"></p>\n<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>可以看到，最终的效果还是可以的，书中给出的代码具体如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"ViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;QuartzCore/QuartzCore.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;GLKit/GLKit.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#define LIGHT_DIRECTION 0, 1, -0.5</span></div><div class=\"line\"><span class=\"meta\">#define AMBIENT_LIGHT 0.5</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *containerView;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) IBOutletCollection(<span class=\"built_in\">UIView</span>) <span class=\"built_in\">NSArray</span> *faces;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)applyLightingToFace:(<span class=\"built_in\">CALayer</span> *)face</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//add lighting layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    layer.frame = face.bounds;</div><div class=\"line\">    [face addSublayer:layer];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//convert face transform to matrix</span></div><div class=\"line\">    <span class=\"comment\">//(GLKMatrix4 has the same structure as CATransform3D)</span></div><div class=\"line\">    <span class=\"built_in\">CATransform3D</span> transform = face.transform;</div><div class=\"line\">    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div><div class=\"line\">    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//get face normal</span></div><div class=\"line\">    GLKVector3 normal = GLKVector3Make(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    normal = GLKMatrix3MultiplyVector3(matrix3, normal);</div><div class=\"line\">    normal = GLKVector3Normalize(normal);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//get dot product with light direction</span></div><div class=\"line\">    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));</div><div class=\"line\">    <span class=\"keyword\">float</span> dotProduct = GLKVector3DotProduct(light, normal);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//set lighting layer opacity</span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> shadow = <span class=\"number\">1</span> + dotProduct - AMBIENT_LIGHT;</div><div class=\"line\">    <span class=\"built_in\">UIColor</span> *color = [<span class=\"built_in\">UIColor</span> colorWithWhite:<span class=\"number\">0</span> alpha:shadow];</div><div class=\"line\">    layer.backgroundColor = color.CGColor;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFace:(<span class=\"built_in\">NSInteger</span>)index withTransform:(<span class=\"built_in\">CATransform3D</span>)transform</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//get the face view and add it to the container</span></div><div class=\"line\">    <span class=\"built_in\">UIView</span> *face = <span class=\"keyword\">self</span>.faces[index];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.containerView addSubview:face];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//center the face view within the container</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> containerSize = <span class=\"keyword\">self</span>.containerView.bounds.size;</div><div class=\"line\">    face.center = <span class=\"built_in\">CGPointMake</span>(containerSize.width / <span class=\"number\">2.0</span>,</div><div class=\"line\">                              containerSize.height / <span class=\"number\">2.0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//apply the transform</span></div><div class=\"line\">    face.layer.transform = transform;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//apply lighting</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> applyLightingToFace:face.layer];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//set up the container sublayer transform</span></div><div class=\"line\">    <span class=\"built_in\">CATransform3D</span> perspective = <span class=\"built_in\">CATransform3DIdentity</span>;</div><div class=\"line\">    perspective.m34 = <span class=\"number\">-1.0</span> / <span class=\"number\">500.0</span>;</div><div class=\"line\">    perspective = <span class=\"built_in\">CATransform3DRotate</span>(perspective, -M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    perspective = <span class=\"built_in\">CATransform3DRotate</span>(perspective, -M_PI_4, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">self</span>.containerView.layer.sublayerTransform = perspective;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 1</span></div><div class=\"line\">    <span class=\"built_in\">CATransform3D</span> transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">0</span> withTransform:transform];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 2</span></div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DRotate</span>(transform, M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">1</span> withTransform:transform];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 3</span></div><div class=\"line\">    <span class=\"comment\">//move this code after the setup for face no. 6 to enable button</span></div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-100</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DRotate</span>(transform, M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">2</span> withTransform:transform];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 4</span></div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DRotate</span>(transform, -M_PI_2, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">3</span> withTransform:transform];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 5</span></div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">-100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DRotate</span>(transform, -M_PI_2, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">4</span> withTransform:transform];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//add cube face 6</span></div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-100</span>);</div><div class=\"line\">    transform = <span class=\"built_in\">CATransform3DRotate</span>(transform, M_PI, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    [<span class=\"keyword\">self</span> addFace:<span class=\"number\">5</span> withTransform:transform];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>但是运行的时候就有两个问题：</p>\n<ul>\n<li>程序无法正确运行</li>\n<li>即使程序正确运行，为什么会产生效果图那种界面，里面的各种变换是如何实现的</li>\n</ul>\n<h2 id=\"Solve\"><a href=\"#Solve\" class=\"headerlink\" title=\"Solve\"></a>Solve</h2><h3 id=\"程序无法正确运行\"><a href=\"#程序无法正确运行\" class=\"headerlink\" title=\"程序无法正确运行\"></a>程序无法正确运行</h3><p>直接把书上的源码拿出来编译运行的时候，会发现程序显示一片空白，并没有像效果图中那样，经过Debug发现，问题在下面这行代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div></pre></td></tr></table></figure>\n<p>这其中transform是CATransform3D类型的，该类型定义如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m11, m12, m13, m14;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m21, m22, m23, m24;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m31, m32, m33, m34;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m41, m42, m43, m44;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span> <span class=\"built_in\">CATransform3D</span>;</div></pre></td></tr></table></figure>\n<p>而CGFloat在64位环境下是double，所以CATransform3D实际上是有16个double元素的结构体，而GLKMatrix4定义如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">union</span> _GLKMatrix4</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">float</span> m00, m01, m02, m03;</div><div class=\"line\">        <span class=\"keyword\">float</span> m10, m11, m12, m13;</div><div class=\"line\">        <span class=\"keyword\">float</span> m20, m21, m22, m23;</div><div class=\"line\">        <span class=\"keyword\">float</span> m30, m31, m32, m33;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">float</span> m[<span class=\"number\">16</span>];</div><div class=\"line\">&#125; __attribute__((aligned(<span class=\"number\">16</span>)));</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _GLKMatrix4 GLKMatrix4;</div></pre></td></tr></table></figure>\n<p>可以看到它里面是16个float元素，所以很明显，直接对transform取址再强转为GLKMatrix4类型会发生截断错误，将该行代码改为下面这样即可：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">GLKMatrix4 matrix4 = GLKMatrix4Make(transform.m11, transform.m12, transform.m13, transform.m14, transform.m21, transform.m22, transform.m23, transform.m24, transform.m31, transform.m32, transform.m33, transform.m34, transform.m41, transform.m42, transform.m43, transform.m44);</div></pre></td></tr></table></figure>\n<h3 id=\"3D变换-amp-透视投影\"><a href=\"#3D变换-amp-透视投影\" class=\"headerlink\" title=\"3D变换 &amp; 透视投影\"></a>3D变换 &amp; 透视投影</h3><h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/%E5%9D%90%E6%A0%87%E7%B3%BB.png\" alt=\"坐标系\"></p>\n<p>首先，在三维空间中，对于一个向量$v$以及基$o-xyz$，可以找到一组坐标$(v_1,v_2,v_3)$，使得</p>\n<p>$$v = v_1x + v_2y + v_3z \\tag{1}$$</p>\n<p>而对于一个点p，则可以找到一组坐标$(p_1,p_2,p_3)$，使得</p>\n<p>$$p-o = p_1x + p_2y + p_3z\\tag{2}$$</p>\n<p>从上面对向量和点的表达，我们可以看出为了在坐标系中表示一个点（如p），我们把点的位置看作是对这个基的原点o所进行的一个位移，即一个向量(p-o)（有的书中把这样的向量叫做位置向量——起始于坐标原点的特殊向量），我们在表达这个向量的同时用等价的方式表达出了点p:</p>\n<p>$$p = o + p_1 x + p_2 y + p_3 z\\tag{3}$$</p>\n<p>(1)(3)是坐标系下表达一个向量和点的不同表达方式。这里可以看出，虽然都是用代数分量的形式表达向量和点，但表达一个点比一个向量需要额外的信息。如果我写出一个代数分量表达$(1, 4, 7)$，并不能确定这是一个点还是一个向量。</p>\n<p>我们现在把(1)(3)写成矩阵的形式：</p>\n<p>$$v=\\begin{pmatrix} x &amp; y &amp; z &amp; o \\\\\\end{pmatrix}\\bullet\\begin{pmatrix}v_1\\\\v_2\\\\v_3\\\\ 0\\\\\\end{pmatrix}$$<br>$$p=\\begin{pmatrix}x &amp; y &amp; z &amp; o \\\\\\end{pmatrix}\\bullet\\begin{pmatrix}p_1\\\\p_2\\\\p_3\\\\1\\\\\\end{pmatrix}$$</p>\n<p>这里$(x,y,z,o)$是坐标基矩阵，右边的列向量分别是向量$v$和点p在基下的坐标。这样，向量和点在同一个基下就有了不同的表达：3D向量的第4个代数分量是0，而3D点的第4个代数分量是1。像这种这种用4个代数分量表示3D几何概念的方式是一种齐次坐标表示。</p>\n<p>对于平移T、旋转R、缩放S这3个最常见的仿射变换，平移变换只对于点才有意义，因为普通向量没有位置概念，只有大小和方向，这可以通过下面的式子清楚地看出：</p>\n<p>$$\\begin{pmatrix}1&amp;0&amp;0&amp;tx\\\\0&amp;1&amp;0&amp;ty\\\\0&amp;0&amp;1&amp;tz\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}=\\begin{pmatrix}x+tx\\\\y+ty\\\\z+tz\\\\1\\\\\\end{pmatrix}$$<br>$$\\begin{pmatrix}1&amp;0&amp;0&amp;tx\\\\0&amp;1&amp;0&amp;ty\\\\0&amp;0&amp;1&amp;tz\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\0\\\\\\end{pmatrix}=\\begin{pmatrix}x\\\\y\\\\z\\\\0\\\\\\end{pmatrix}$$</p>\n<p>而旋转和缩放对于向量和点都有意义，你可以用类似上面齐次表示来检测。从中可以看出，齐次坐标用于仿射变换非常方便。</p>\n<h4 id=\"仿射变换\"><a href=\"#仿射变换\" class=\"headerlink\" title=\"仿射变换\"></a>仿射变换</h4><p>基础的仿射变换有平移、缩放、旋转三种，下面我们以点为例来简单介绍一下这三种变换对应的变换矩阵。</p>\n<h5 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h5><p>在三维齐次坐标表示中，任意点$P=(x,y,z)$通过平移距离$t_x,t_y,t_z$加到P的坐标上而平移到位置$P’=(x’,y’,z’)$ ：</p>\n<p>$$x’=x+t_x,y’=y+t_y,z’=z+t_z$$</p>\n<p>在计算机中，我们为了方便程序处理，通常用矩阵形式来表达三维变换操作，这里，我们用齐次坐标4元列向量的形式表示位置$P和P’$，且变换操作T是4x4矩阵：</p>\n<p>$$\\begin{pmatrix}x’\\\\y’\\\\z’\\\\1\\\\\\end{pmatrix}＝\\begin{pmatrix}1&amp;0&amp;0&amp;t_x\\\\0&amp;1&amp;0&amp;t_y\\\\0&amp;0&amp;1&amp;t_z\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}$$</p>\n<p>在三维空间中，对象的平移通过平移定义该对象的各个点然后在新位置重建该对象而实现。对于由一组多边形表面表示的对象，可以将各个表面的顶点进行平移，然后重新显示新位置的面。</p>\n<h5 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h5><p>我们可以绕空间的任意轴旋转一个对象，但绕平行于坐标轴的轴的旋转是最容易处理的，首先我们来看绕z轴的旋转：</p>\n<p>$$x’=xcos\\theta-ysin\\theta\\\\y’=xsin\\theta+ycos\\theta\\\\z’=z$$</p>\n<p>参数$\\theta$表示指定的绕z轴旋转的角度，而z坐标值在该变换中不变。三维z轴旋转方程可以用齐次坐标形式表示如下：</p>\n<p>$$\\begin{pmatrix}x’\\\\y’\\\\z’\\\\1\\\\\\end{pmatrix}＝\\begin{pmatrix}cos\\theta&amp;-sin\\theta&amp;0&amp;0\\\\sin\\theta&amp;cos\\theta&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}$$</p>\n<p>同理，可以得到x轴旋转公式：</p>\n<p>$$y’=ycos\\theta-zsin\\theta\\\\z’=ysin\\theta+zcos\\theta\\\\x’=x$$</p>\n<p>以及y轴旋转公式：</p>\n<p>$$z’=zcos\\theta-xsin\\theta\\\\x’=zsin\\theta+xcos\\theta\\\\y’=y$$</p>\n<p>相应的旋转方程如下：</p>\n<p>$$\\begin{pmatrix}x’\\\\y’\\\\z’\\\\1\\\\\\end{pmatrix}＝\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\0&amp;cos\\theta&amp;-sin\\theta&amp;0\\\\0&amp;sin\\theta&amp;cos\\theta&amp;0\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}$$<br>$$\\begin{pmatrix}x’\\\\y’\\\\z’\\\\1\\\\\\end{pmatrix}＝\\begin{pmatrix}cos\\theta&amp;0&amp;sin\\theta&amp;0\\\\0&amp;1&amp;0&amp;0\\\\-sin\\theta&amp;0&amp;cos\\theta&amp;0\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}$$</p>\n<h5 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h5><p>缩放比较简单，进行简单的各坐标轴方向乘积运算即可，缩放方程如下：</p>\n<p>$$\\begin{pmatrix}x’\\\\y’\\\\z’\\\\1\\\\\\end{pmatrix}＝\\begin{pmatrix}s_x&amp;0&amp;0&amp;0\\\\0&amp;s_y&amp;0&amp;0\\\\0&amp;0&amp;x_z&amp;0\\\\0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}x\\\\y\\\\z\\\\1\\\\\\end{pmatrix}$$</p>\n<h4 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h4><p>iOS中的CALayer的3D本质上并不能算真正的3D(其视点即观察点或者所谓的照相机的位置是无法变换的)，而只是3D在二维平面上的投影，投影平面就是手机屏幕也就是xy轴组成的平面(注意iOS中为左手坐标系)，那么视点的位置是如何确定的呢？可以通过CATransform3D中的$m_{34}$来间接指定， $m_{34} = -1/z$，其中$z$为观察点在z轴上的值,而Layer的z轴的位置则是通过anchorPoint来指定的，所谓的anchorPoint(锚点)就是在变换中保持不变的点，也就是某个Layer在变换中的原点，xyz三轴相交于此点。</p>\n<p>$m_{34} = -1/z$中，当$z$为正的时候，是我们人眼观察现实世界的效果，即在投影平面上表现出近大远小的效果，$z$越靠近原点则这种效果越明显，越远离原点则越来越不明显，当$z$为正无穷大的时候，则失去了近大远小的效果，此时投影线垂直于投影平面，也就是视点在无穷远处，CATransform3D中$m_{34}$的默认值为0，即视点在无穷远处。</p>\n<p>下面以点$P(10,0,-10)$为例看一下在iOS的透视投影机制中，三维空间上的一点是如何投影到投影平面（手机屏幕）上的。</p>\n<p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1.png\" alt=\"透视投影\"></p>\n<p>图中绿色点为点P，视点为观察点，也就是说，我们从视点的位置去观察P点，那么虚线就为投影线，其与x轴的交点即为投影点，通过设置$m_{34}=-1/500$，我们得到投影矩阵如下：</p>\n<p>$$\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;-\\frac{1}{500}&amp;1\\\\\\end{pmatrix}$$</p>\n<p>将其与点P相乘得到：</p>\n<p>$$\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;-\\frac{1}{500}&amp;1\\\\\\end{pmatrix}\\bullet\\begin{pmatrix}10\\\\0\\\\-10\\\\1\\end{pmatrix}=\\begin{pmatrix}10\\\\0\\\\-10\\\\1.02\\end{pmatrix}$$</p>\n<p>将得到的点转为齐次坐标即为：</p>\n<p>$$\\begin{pmatrix}10/1.02\\\\0\\\\-10/1.02\\\\1\\end{pmatrix}$$</p>\n<p>与上面图中的示意相同。由于是直接投影到xy平面，所以直接将z坐标置为0即可。</p>\n<h2 id=\"Display\"><a href=\"#Display\" class=\"headerlink\" title=\"Display\"></a>Display</h2><h3 id=\"正方体显示\"><a href=\"#正方体显示\" class=\"headerlink\" title=\"正方体显示\"></a>正方体显示</h3><p>简单说完上述的基本理论，再回到问题，看看前文代码中所构建的正方体为何在手机屏幕上显示为那样。</p>\n<p>看代码可知，Demo中一共初始化了6个View，分别当作正方体的6面，其中每一面初始化的时候都进行了平移和旋转，可以简单想象一下，6个面经过平移旋转，恰好在三维空间内构建为一个正方体，正方体中心为坐标原点，边长为200，八个顶点坐标分别为：</p>\n<p>$$(100,100,100)\\\\(100,100,-100)\\\\(100,-100,100)\\\\(100,-100,-100)\\\\(-100,100,100)\\\\(-100,100,-100)\\\\(-100,-100,100)\\\\(-100,-100,-100)$$</p>\n<p>方便起见，我们只需要知道这八个点经过各种变换后在投影平面的位置就可以知道整个立方体看起来的效果。</p>\n<p>再来看看整个容器View进行了哪些变换：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CATransform3D</span> perspective = <span class=\"built_in\">CATransform3DIdentity</span>;</div><div class=\"line\">perspective.m34 = <span class=\"number\">-1.0</span> / <span class=\"number\">500.0</span>;</div><div class=\"line\">perspective = <span class=\"built_in\">CATransform3DRotate</span>(perspective, -M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">perspective = <span class=\"built_in\">CATransform3DRotate</span>(perspective, -M_PI_4, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">self</span>.containerView.layer.sublayerTransform = perspective;</div></pre></td></tr></table></figure>\n<p>可以看到，为了达到逼真的效果，程序首先将$m_{34}$进行了设置，然后将整个图层先绕x轴旋转$-45^\\circ$，再绕y轴旋转了$-45^\\circ$，这样一来，最终的变换矩阵perspective即为：</p>\n<p>$$<br>\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;-\\frac{1}{500}&amp;1\\\\\\end{pmatrix}\\bullet<br>\\begin{pmatrix}<br>\\frac{\\sqrt 2}{2}&amp;0&amp;-\\frac{\\sqrt 2}{2}&amp;0\\\\<br>0&amp;1&amp;0&amp;0\\\\<br>\\frac{\\sqrt 2}{2}&amp;0&amp;\\frac{\\sqrt 2}{2}&amp;0\\\\<br>0&amp;0&amp;0&amp;1\\\\<br>\\end{pmatrix}\\bullet<br>\\begin{pmatrix}1&amp;0&amp;0&amp;0\\\\<br>0&amp;\\frac{\\sqrt 2}{2}&amp;\\frac{\\sqrt 2}{2}&amp;0\\\\<br>0&amp;-\\frac{\\sqrt 2}{2}&amp;\\frac{\\sqrt 2}{2}&amp;0\\\\<br>0&amp;0&amp;0&amp;1\\\\\\end{pmatrix}\\\\=<br>\\begin{pmatrix}<br>\\frac{\\sqrt 2}{2}&amp;0&amp;-\\frac{\\sqrt 2}{2}&amp;0\\\\<br>\\frac{1}{2}&amp;\\frac{\\sqrt 2}{2}&amp;\\frac{1}{2}&amp;0\\\\<br>\\frac{1}{2}&amp;-\\frac{\\sqrt 2}{2}&amp;\\frac{1}{2}&amp;0\\\\<br>-\\frac{1}{1000}&amp;\\frac{\\sqrt 2}{1000}&amp;-\\frac{1}{1000}&amp;1\\\\<br>\\end{pmatrix}=perspective<br>$$</p>\n<p>得到了变换矩阵，我们再将上述的八个点一一与矩阵相乘，便能得到它们在投影平面上的位置，这里以$(100,100,100,1)$为例：</p>\n<p>$$<br>\\begin{pmatrix}<br>\\frac{\\sqrt 2}{2}&amp;0&amp;-\\frac{\\sqrt 2}{2}&amp;0\\\\<br>\\frac{1}{2}&amp;\\frac{\\sqrt 2}{2}&amp;\\frac{1}{2}&amp;0\\\\<br>\\frac{1}{2}&amp;-\\frac{\\sqrt 2}{2}&amp;\\frac{1}{2}&amp;0\\\\<br>-\\frac{1}{1000}&amp;\\frac{\\sqrt 2}{1000}&amp;-\\frac{1}{1000}&amp;1\\\\<br>\\end{pmatrix}\\bullet<br>\\begin{pmatrix}100\\\\100\\\\100\\\\1\\\\\\end{pmatrix}=<br>\\begin{pmatrix}0\\\\100+50\\sqrt 2\\\\100-50\\sqrt 2\\\\\\frac{8+\\sqrt 2}{10}\\\\\\end{pmatrix}\\to<br>\\begin{pmatrix}0\\\\181.33\\\\0\\\\1\\\\\\end{pmatrix}<br>$$</p>\n<p>其他七个点计算如下：</p>\n<p>$$<br>(123.90,61.95,0,1)\\\\<br>(0,44.47,0,1)\\\\<br>(161.71,-82.36,0,1)\\\\<br>(-123.90,61.95,0,1)\\\\<br>(0,-21.83,0,1)\\\\<br>(-161.71,-82.36,0,1)\\\\<br>(0,-161.26,0,1)<br>$$</p>\n<p>将上述八个点在xy平面上画出来如下图所示：</p>\n<p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/perpective.png\" alt=\"perpective\"></p>\n<p>是不是跟前面效果图中的一模一样呢。至此，我们已经了解了三维空间中的对象是如何经过一系列变换投影到手机屏幕上的，下面，我们再来看看正方体不同平面的光照阴影是如何计算的。</p>\n<h3 id=\"光照阴影效果\"><a href=\"#光照阴影效果\" class=\"headerlink\" title=\"光照阴影效果\"></a>光照阴影效果</h3><p>先来看代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)applyLightingToFace:(<span class=\"built_in\">CALayer</span> *)face</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//add lighting layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    layer.frame = face.bounds;</div><div class=\"line\">    [face addSublayer:layer];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//convert face transform to matrix</span></div><div class=\"line\">    <span class=\"comment\">//(GLKMatrix4 has the same structure as CATransform3D)</span></div><div class=\"line\">    <span class=\"built_in\">CATransform3D</span> transform = face.transform;</div><div class=\"line\">    GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div><div class=\"line\">    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//get face normal</span></div><div class=\"line\">    GLKVector3 normal = GLKVector3Make(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    normal = GLKMatrix3MultiplyVector3(matrix3, normal);</div><div class=\"line\">    normal = GLKVector3Normalize(normal);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//get dot product with light direction</span></div><div class=\"line\">    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));</div><div class=\"line\">    <span class=\"keyword\">float</span> dotProduct = GLKVector3DotProduct(light, normal);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//set lighting layer opacity</span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> shadow = <span class=\"number\">1</span> + dotProduct - AMBIENT_LIGHT;</div><div class=\"line\">    <span class=\"built_in\">UIColor</span> *color = [<span class=\"built_in\">UIColor</span> colorWithWhite:<span class=\"number\">0</span> alpha:shadow];</div><div class=\"line\">    layer.backgroundColor = color.CGColor;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述代码分为几个步骤：</p>\n<ol>\n<li>将齐次坐标的4维变换矩阵降为3维，因为这里我们是用的平行光，不需要平移，而原始变换矩阵的第四维主要是平移以及透视投影用，所以这里直接用前3维即可。</li>\n<li>获取照射平面的法向量。因为我们的每个面都是由初始的平行于xy平面的面经过一系列变换而来，而初始平面的法向量是$(0,0,1)$，所以我们只需要将初始法向量经过同样的变换，即可求得照射平面的法向量。</li>\n<li>将光照向量与照射平面法向量做点积运算，即可求得光照向量在照射平面的投影，推导如下：</li>\n</ol>\n<p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/vector.png\" alt=\"vector\"></p>\n<p>假设$u$在$v$上的投影向量是$u’$，且向量$u$和$v$的夹角为$\\theta$。一个向量有两个属性，大小和方向，我们先确定$u’$的大小（即长度，或者模），从$u$的末端做$v$的垂线，那么$d$就是$u’$的长度。而$u’$和$v$的方向是相同的，$v$的方向$v/|v|$也就是$u’$的方向。所以有</p>\n<p>$$u’=d\\frac{v}{|v|}\\tag{1}$$</p>\n<p>再求$d$的长度</p>\n<p>$$d=|u|cos\\theta\\tag{2}$$</p>\n<p>最后求$cos\\theta$</p>\n<p>$$cos\\theta=\\frac{u\\cdot v}{|u||v|}\\tag{3}$$</p>\n<p>得到</p>\n<p>$$u’=\\frac{u\\cdot v}{|v|^2}v$$</p>\n<p>这就是最终的投影向量，长度$d$则为</p>\n<p>$$|u’|=|u|cos\\theta=|u|\\frac{u\\cdot v}{|u||v|}=\\frac{u\\cdot v}{|v|}$$</p>\n<p>因为$v$是单位向量，长度为一，所以最终的光强反应在代码中就是两个向量做点积。</p>\n<p>至此，整个代码都已经非常清楚了，完。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC\" target=\"_blank\" rel=\"external\">iOS Core Animation: Advanced Techniques</a></li>\n<li><a href=\"https://www.amazon.com/Computer-Graphics-Open-GL-4th/dp/0136053580\" target=\"_blank\" rel=\"external\">Computer Graphics with Open GL</a></li>\n<li><a href=\"http://geeklu.com/2012/07/ios-3d-perspective/\" target=\"_blank\" rel=\"external\">iOS的三维透视投影</a></li>\n<li><a href=\"http://blog.csdn.net/popy007/article/details/1797121\" target=\"_blank\" rel=\"external\">深入探索透视投影变换</a></li>\n</ul>\n","categories":["🐵"],"tags":["iOS","Core Animation"]},{"title":"iOS中的Hit-Testing","url":"http://www.dengbo.me/2016/08/17/iOS中的Hit-Testing/","content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>美团iOS客户端电影频道中，影院列表的界面如下所示：</p>\n<p><a href=\"url\"><img src=\"http://7otic0.com1.z0.glb.clouddn.com/CinemaCellWithScheduler.jpeg\" alt=\"影院列表Cell\" height=\"200\" width=\"250\"></a></p>\n<p>每个影院Cell中的放映场次部分，也就是图中红色矩形框标记的部分，都是用UICollectionView完成的，之前代码将UICollectionView的宽度固定，所以导致点击空白区域的时候，实际上也是点击到了UICollectionView上，继而使得用户点击无响应，影响了用户体验。</p>\n<p>所以现在需要对其进行改进，使得用户点击放映场次旁边的空白区域的时候，跟点击影院Cell的响应一样，都进入下级页面，而不是无响应。</p>\n<h2 id=\"第一反应\"><a href=\"#第一反应\" class=\"headerlink\" title=\"第一反应\"></a>第一反应</h2><p>为了解决上面的问题，自己首先想到的是将UICollectionView的宽度不固定，而是根据内容自动计算宽度，这样UICollectionView就不会遮挡住影院Cell，点击空白区域也就是直接点击影院Cell了，但是这样有个问题，就是虽然右边空白区域的问题解决了，但是放映场次之间的间隙仍然会点击无响应，某种程度上来说，还是有瑕疵。</p>\n<p>第二个想法是，利用UICollectionView的backgroundView做文章，我们可以实例化一个backgroundView，然后为它添加一个tap手势的监听，那么当用户点击UICollectionView的空白区域时，就可以捕获到该事件，从而做出相应的响应，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.collectionView.backgroundView = [[<span class=\"built_in\">UIView</span> alloc] init];</div><div class=\"line\">[<span class=\"keyword\">self</span>.collectionView addGestureRecognizer:[[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(handleBackgroundTap)]];</div></pre></td></tr></table></figure>\n<p>这样我们就能在<code>handleBackgroundTap</code>中处理点击事件，然而问题来了，这里的collectionView是影院Cell的一个属性，那么如何在<code>handleBackgroundTap</code>中调用<code>- tableView:didSelectRowAtIndexPath:</code>方法呢，想了一会儿，感觉没有特别简洁的方法，所以就放弃了这种思路。</p>\n<h2 id=\"Hit-Testing-in-iOS\"><a href=\"#Hit-Testing-in-iOS\" class=\"headerlink\" title=\"Hit-Testing in iOS\"></a>Hit-Testing in iOS</h2><p>上述两种思路都毙掉后，看了一下Apple关于<a href=\"https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4\" target=\"_blank\" rel=\"external\">Hit-Testing</a>的文档，了解了一下iOS中触摸事件的原理和流程，发现可以通过覆写<code>-hitTest:withEvent:</code>方法来达到目的，这里先简单说一下Hit-Testing。</p>\n<p>iOS用hit-testing机制来找到用来响应一个触摸事件的view。Hit-testing的主要工作就是检查某个触摸事件发生的位置是否在相关联的某个view边界内。如果是，它就会递归检查该view的subviews。而整个view树中，最底层的一个包含触摸位置的view将会成为hit-test view。在iOS找到来hit-test view后，就将触摸事件交给该view去处理。</p>\n<p><a href=\"url\"><img src=\"https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\" alt=\"Hit-testing returns the subview that was touched\" height=\"360\" width=\"240\"></a></p>\n<p>为了解释一下hit-testing机制，以上图为例具体说明一下，假设用户点击了View E区域，那么iOS通过以下顺序来检查subviews以找到hit-test view：</p>\n<ol>\n<li>触摸位置在视图A的边界内，所以它会继续检查自视图B和C。</li>\n<li>触摸位置不在视图B的边界内，但是在视图C的边界内，所以继续检查自视图D和E。</li>\n<li>触摸位置不在视图D的边界内，但是在视图E的边界内。</li>\n</ol>\n<p>视图E是视图层级体系中包含触摸位置的最底层视图，所以它就成为了hit-test view。<br>当然，这里还有一种普遍情况就是，假如视图D和视图E重叠了，而用户恰好点击了重叠区域，那么这个时候，hit-test view将会是subview索引中的较大者，也就是说，如果是先addSubview D，再addSubview E，那么就是E，反之则是D。</p>\n<p>下面是hit-testing的流程图：</p>\n<p><img src=\"http://7otic0.com1.z0.glb.clouddn.com/hit-test-flowchart.png\" alt=\"hit-test-flowchart\"></p>\n<p>这个图清楚的解释了<code>-hitTest:withEvent:</code>的具体实现，相应的代码实现则是：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.isUserInteractionEnabled || <span class=\"keyword\">self</span>.isHidden || <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> pointInside:point withEvent:event]) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">UIView</span> *subview <span class=\"keyword\">in</span> [<span class=\"keyword\">self</span>.subviews reverseObjectEnumerator]) &#123;</div><div class=\"line\">            <span class=\"built_in\">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class=\"keyword\">self</span>];</div><div class=\"line\">            <span class=\"built_in\">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</div><div class=\"line\">            <span class=\"keyword\">if</span> (hitTestView) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> hitTestView;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>hitTest:withEvent:</code>方法首先会检查一个view是否允许接收触摸事件，一个view允许接收触摸事件的条件是：</p>\n<ul>\n<li>view为被隐藏:<code>self.hidden == NO</code></li>\n<li>view允许交互:<code>self.userInteractionEnabled == YES</code></li>\n<li>view透明度大于0.01:<code>self.alpha &gt; 0.01</code></li>\n<li>触摸位置在view边界内:<code>pointInside:withEvent: == YES</code></li>\n</ul>\n<p>如果一个view允许接收触摸事件，这个方法就会通过按逆序顺序向subviews发送<code>hitTest:withEvent:</code>消息的方式遍历，直到返回一个非空值。如果所有subviews返回空或者没有subview，则返回自身。</p>\n<p>否则，如果一个视图不允许接收触摸事件，这个方法直接放回nil，并且不再遍历视图层级上的自视图。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在了解了iOS的hit-testing机制后，再回到开头提到的问题，可以发现，这里我们可以直接通过重写UICollectionView的<code>hitTest:withEvent:</code>方法，改变它接收触摸事件的默认处理方式即可。也就是说，当hit-test检查到UICollectionView的时候，加以判断，如果点击的是放映场次Cell，那么直接返回该Cell，如果点击的是空白区域，那么我们就不返回UICollectionView，而是直接返回nil，这样，最底层的响应者就应该是影院Cell，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyUICollectionView</span> : <span class=\"title\">UICollectionView</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyUICollectionView</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.isUserInteractionEnabled || <span class=\"keyword\">self</span>.isHidden || <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">UIView</span> *subview <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.subviews.reverseObjectEnumerator) &#123;</div><div class=\"line\">        <span class=\"built_in\">CGPoint</span> subPoint = [subview convertPoint:point fromView:<span class=\"keyword\">self</span>];</div><div class=\"line\">        <span class=\"built_in\">UIView</span> *result = [subview hitTest:subPoint withEvent:event];</div><div class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样能完全达到我们的目的，但是看上去有点别扭，因为我们新建了一个<code>MyUICollectionView</code>类，显得非常突兀，那么，换个思路，既然我们能在UICollectionView中重写<code>hitTest:withEvent:</code>方法，那么作为collectionView的superview，我们能不能直接在影院Cell中重写该方法呢，答案是肯定的。在影院Cell中，我们可以取得superclass UIView的<code>hitTest:withEvent:</code>方法的返回结果，进行中途拦截，判断返回结果是否为collectionView，如果是，我们返回影院Cell自身，如果不是，原样返回就行：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *view = [<span class=\"keyword\">super</span> hitTest:point withEvent:event];</div><div class=\"line\">    <span class=\"keyword\">if</span> (view == <span class=\"keyword\">self</span>.collectionView) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在看来，这才是最简单有效的方法。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW2\" target=\"_blank\" rel=\"external\">Event Delivery: The Responder Chain</a></li>\n<li><a href=\"http://smnh.me/hit-testing-in-ios/\" target=\"_blank\" rel=\"external\">Hit-Testing in iOS</a></li>\n<li><a href=\"http://stackoverflow.com/questions/11770743/capturing-touches-on-a-subview-outside-the-frame-of-its-superview-using-hittest\" target=\"_blank\" rel=\"external\">Capturing touches on a subview outside the frame of its superview using hitTest:withEvent:</a></li>\n</ul>\n","categories":["🐵"],"tags":["iOS"]},{"title":"about","url":"http://www.dengbo.me/about/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://www.dengbo.me/tag/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://www.dengbo.me/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://www.dengbo.me/search/index.html","content":"","categories":[],"tags":[]}]